{"version":3,"file":"react-flow-smart-edge.cjs.production.min.js","sources":["../src/functions/guaranteeWalkablePath.ts","../src/functions/pointConversion.ts","../src/functions/utils.ts","../src/functions/drawSvgPath.ts","../src/functions/generatePath.ts","../src/getSmartEdge/index.ts","../src/functions/getBoundingBoxes.ts","../src/functions/createGrid.ts","../src/SmartEdge/index.tsx","../src/SmartBezierEdge/index.tsx","../src/SmartStepEdge/index.tsx","../src/SmartStraightEdge/index.tsx"],"sourcesContent":["import type { Grid } from 'pathfinding'\nimport type { Position, XYPosition } from 'reactflow'\n\ntype Direction = 'top' | 'bottom' | 'left' | 'right'\n\nexport const getNextPointFromPosition = (\n\tpoint: XYPosition,\n\tposition: Direction\n): XYPosition => {\n\tswitch (position) {\n\t\tcase 'top':\n\t\t\treturn { x: point.x, y: point.y - 1 }\n\t\tcase 'bottom':\n\t\t\treturn { x: point.x, y: point.y + 1 }\n\t\tcase 'left':\n\t\t\treturn { x: point.x - 1, y: point.y }\n\t\tcase 'right':\n\t\t\treturn { x: point.x + 1, y: point.y }\n\t}\n}\n\n/**\n * Guarantee that the path is walkable, even if the point is inside a non\n * walkable area, by adding a walkable path in the direction of the point's\n * Position.\n */\nexport const guaranteeWalkablePath = (\n\tgrid: Grid,\n\tpoint: XYPosition,\n\tposition: Position\n) => {\n\tlet node = grid.getNodeAt(point.x, point.y)\n\twhile (!node.walkable) {\n\t\tgrid.setWalkableAt(node.x, node.y, true)\n\t\tconst next = getNextPointFromPosition(node, position)\n\t\tnode = grid.getNodeAt(next.x, next.y)\n\t}\n}\n","import type { XYPosition } from 'reactflow'\n\n/**\n * Each bounding box is a collection of X/Y points in a graph, and we\n * need to convert them to \"occupied\" cells in a 2D grid representation.\n *\n * The top most position of the grid (grid[0][0]) needs to be equivalent\n * to the top most point in the graph (the graph.topLeft point).\n *\n * Since the top most point can have X/Y values different than zero,\n * and each cell in a grid represents a 10x10 pixel area in the grid (or a\n * gridRatio area), there's need to be a conversion between a point in a graph\n * to a point in the grid.\n *\n * We do this conversion by dividing a graph point X/Y values by the grid ratio,\n * and \"shifting\" their values up or down, depending on the values of the top\n * most point in the graph. The top most point in the graph will have the\n * smallest values for X and Y.\n *\n * We avoid setting nodes in the border of the grid (x=0 or y=0), so there's\n * always a \"walkable\" area around the grid.\n */\nexport const graphToGridPoint = (\n\tgraphPoint: XYPosition,\n\tsmallestX: number,\n\tsmallestY: number,\n\tgridRatio: number\n): XYPosition => {\n\tlet x = graphPoint.x / gridRatio\n\tlet y = graphPoint.y / gridRatio\n\n\tlet referenceX = smallestX / gridRatio\n\tlet referenceY = smallestY / gridRatio\n\n\tif (referenceX < 1) {\n\t\twhile (referenceX !== 1) {\n\t\t\treferenceX++\n\t\t\tx++\n\t\t}\n\t} else if (referenceX > 1) {\n\t\twhile (referenceX !== 1) {\n\t\t\treferenceX--\n\t\t\tx--\n\t\t}\n\t} else {\n\t\t// Nothing to do\n\t}\n\n\tif (referenceY < 1) {\n\t\twhile (referenceY !== 1) {\n\t\t\treferenceY++\n\t\t\ty++\n\t\t}\n\t} else if (referenceY > 1) {\n\t\twhile (referenceY !== 1) {\n\t\t\treferenceY--\n\t\t\ty--\n\t\t}\n\t} else {\n\t\t// Nothing to do\n\t}\n\n\treturn { x, y }\n}\n\n/**\n * Converts a grid point back to a graph point, using the reverse logic of\n * graphToGridPoint.\n */\nexport const gridToGraphPoint = (\n\tgridPoint: XYPosition,\n\tsmallestX: number,\n\tsmallestY: number,\n\tgridRatio: number\n): XYPosition => {\n\tlet x = gridPoint.x * gridRatio\n\tlet y = gridPoint.y * gridRatio\n\n\tlet referenceX = smallestX\n\tlet referenceY = smallestY\n\n\tif (referenceX < gridRatio) {\n\t\twhile (referenceX !== gridRatio) {\n\t\t\treferenceX = referenceX + gridRatio\n\t\t\tx = x - gridRatio\n\t\t}\n\t} else if (referenceX > gridRatio) {\n\t\twhile (referenceX !== gridRatio) {\n\t\t\treferenceX = referenceX - gridRatio\n\t\t\tx = x + gridRatio\n\t\t}\n\t} else {\n\t\t// Nothing to do\n\t}\n\n\tif (referenceY < gridRatio) {\n\t\twhile (referenceY !== gridRatio) {\n\t\t\treferenceY = referenceY + gridRatio\n\t\t\ty = y - gridRatio\n\t\t}\n\t} else if (referenceY > gridRatio) {\n\t\twhile (referenceY !== gridRatio) {\n\t\t\treferenceY = referenceY - gridRatio\n\t\t\ty = y + gridRatio\n\t\t}\n\t} else {\n\t\t// Nothing to do\n\t}\n\n\treturn { x, y }\n}\n","export const round = (x: number, multiple = 10) =>\n\tMath.round(x / multiple) * multiple\n\nexport const roundDown = (x: number, multiple = 10) =>\n\tMath.floor(x / multiple) * multiple\n\nexport const roundUp = (x: number, multiple = 10) =>\n\tMath.ceil(x / multiple) * multiple\n\nexport const toInteger = (value: number, min = 0) => {\n\tlet result = Math.max(Math.round(value), min)\n\tresult = Number.isInteger(result) ? result : min\n\tresult = result >= min ? result : min\n\treturn result\n}\n","import type { XYPosition } from 'reactflow'\n\n/**\n * Takes source and target {x, y} points, together with an array of number\n * tuples [x, y] representing the points along the path, and returns a string\n * to be used as the SVG path.\n */\nexport type SVGDrawFunction = (\n\tsource: XYPosition,\n\ttarget: XYPosition,\n\tpath: number[][]\n) => string\n\n/**\n * Draws a SVG path from a list of points, using straight lines.\n */\nexport const svgDrawStraightLinePath: SVGDrawFunction = (\n\tsource,\n\ttarget,\n\tpath\n) => {\n\tlet svgPathString = `M ${source.x}, ${source.y} `\n\n\tpath.forEach((point) => {\n\t\tconst [x, y] = point\n\t\tsvgPathString += `L ${x}, ${y} `\n\t})\n\n\tsvgPathString += `L ${target.x}, ${target.y} `\n\n\treturn svgPathString\n}\n\n/**\n * Draws a SVG path from a list of points, using rounded lines.\n */\nexport const svgDrawSmoothLinePath: SVGDrawFunction = (\n\tsource,\n\ttarget,\n\tpath\n) => {\n\tconst points = [[source.x, source.y], ...path, [target.x, target.y]]\n\treturn quadraticBezierCurve(points)\n}\n\nconst quadraticBezierCurve = (points: number[][]) => {\n\tconst X = 0\n\tconst Y = 1\n\tlet point = points[0]\n\n\tconst first = points[0]\n\tlet svgPath = `M${first[X]},${first[Y]}M`\n\n\tfor (let i = 0; i < points.length; i++) {\n\t\tconst next = points[i]\n\t\tconst midPoint = getMidPoint(point[X], point[Y], next[X], next[Y])\n\n\t\tsvgPath += ` ${midPoint[X]},${midPoint[Y]}`\n\t\tsvgPath += `Q${next[X]},${next[Y]}`\n\t\tpoint = next\n\t}\n\n\tconst last = points[points.length - 1]\n\tsvgPath += ` ${last[0]},${last[1]}`\n\n\treturn svgPath\n}\n\nconst getMidPoint = (Ax: number, Ay: number, Bx: number, By: number) => {\n\tconst Zx = (Ax - Bx) / 2 + Bx\n\tconst Zy = (Ay - By) / 2 + By\n\treturn [Zx, Zy]\n}\n","// FIXME: The \"pathfinding\" module doe not have proper typings.\n/* eslint-disable\n\t@typescript-eslint/no-unsafe-call,\n\t@typescript-eslint/no-unsafe-member-access,\n\t@typescript-eslint/no-unsafe-assignment,\n\t@typescript-eslint/ban-ts-comment,\n*/\nimport {\n\tAStarFinder,\n\tJumpPointFinder,\n\tUtil,\n\tDiagonalMovement\n} from 'pathfinding'\nimport type { Grid } from 'pathfinding'\nimport type { XYPosition } from 'reactflow'\n\n/**\n * Takes source and target {x, y} points, together with an grid representation\n * of the graph, and returns two arrays of number tuples [x, y]. The first\n * array represents the full path from source to target, and the second array\n * represents a condensed path from source to target.\n */\nexport type PathFindingFunction = (\n\tgrid: Grid,\n\tstart: XYPosition,\n\tend: XYPosition\n) => {\n\tfullPath: number[][]\n\tsmoothedPath: number[][]\n} | null\n\nexport const pathfindingAStarDiagonal: PathFindingFunction = (\n\tgrid,\n\tstart,\n\tend\n) => {\n\ttry {\n\t\tconst finder = new AStarFinder({\n\t\t\tdiagonalMovement: DiagonalMovement.Always\n\t\t})\n\t\tconst fullPath = finder.findPath(start.x, start.y, end.x, end.y, grid)\n\t\tconst smoothedPath = Util.smoothenPath(grid, fullPath)\n\t\tif (fullPath.length === 0 || smoothedPath.length === 0) return null\n\t\treturn { fullPath, smoothedPath }\n\t} catch {\n\t\treturn null\n\t}\n}\n\nexport const pathfindingAStarNoDiagonal: PathFindingFunction = (\n\tgrid,\n\tstart,\n\tend\n) => {\n\ttry {\n\t\tconst finder = new AStarFinder({\n\t\t\tdiagonalMovement: DiagonalMovement.Never\n\t\t})\n\t\tconst fullPath = finder.findPath(start.x, start.y, end.x, end.y, grid)\n\t\tconst smoothedPath = Util.smoothenPath(grid, fullPath)\n\t\tif (fullPath.length === 0 || smoothedPath.length === 0) return null\n\t\treturn { fullPath, smoothedPath }\n\t} catch {\n\t\treturn null\n\t}\n}\n\nexport const pathfindingJumpPointNoDiagonal: PathFindingFunction = (\n\tgrid,\n\tstart,\n\tend\n) => {\n\ttry {\n\t\t// FIXME: The \"pathfinding\" module doe not have proper typings.\n\t\t// @ts-ignore\n\t\tconst finder = new JumpPointFinder({\n\t\t\tdiagonalMovement: DiagonalMovement.Never\n\t\t})\n\t\tconst fullPath = finder.findPath(start.x, start.y, end.x, end.y, grid)\n\t\tconst smoothedPath = fullPath\n\t\tif (fullPath.length === 0 || smoothedPath.length === 0) return null\n\t\treturn { fullPath, smoothedPath }\n\t} catch {\n\t\treturn null\n\t}\n}\n","import {\n\tcreateGrid,\n\tgetBoundingBoxes,\n\tgridToGraphPoint,\n\tpathfindingAStarDiagonal,\n\tsvgDrawSmoothLinePath,\n\ttoInteger\n} from '../functions'\nimport type {\n\tPointInfo,\n\tPathFindingFunction,\n\tSVGDrawFunction\n} from '../functions'\nimport type { Node, EdgeProps } from 'reactflow'\n\nexport type EdgeParams = Pick<\n\tEdgeProps,\n\t| 'sourceX'\n\t| 'sourceY'\n\t| 'targetX'\n\t| 'targetY'\n\t| 'sourcePosition'\n\t| 'targetPosition'\n>\n\nexport type GetSmartEdgeOptions = {\n\tgridRatio?: number\n\tnodePadding?: number\n\tdrawEdge?: SVGDrawFunction\n\tgeneratePath?: PathFindingFunction\n}\n\nexport type GetSmartEdgeParams<NodeDataType = unknown> = EdgeParams & {\n\toptions?: GetSmartEdgeOptions\n\tnodes: Node<NodeDataType>[]\n}\n\nexport type GetSmartEdgeReturn = {\n\tsvgPathString: string\n\tedgeCenterX: number\n\tedgeCenterY: number\n}\n\nexport const getSmartEdge = <NodeDataType = unknown>({\n\toptions = {},\n\tnodes = [],\n\tsourceX,\n\tsourceY,\n\ttargetX,\n\ttargetY,\n\tsourcePosition,\n\ttargetPosition\n}: GetSmartEdgeParams<NodeDataType>): GetSmartEdgeReturn | null => {\n\ttry {\n\t\tconst {\n\t\t\tdrawEdge = svgDrawSmoothLinePath,\n\t\t\tgeneratePath = pathfindingAStarDiagonal\n\t\t} = options\n\n\t\tlet { gridRatio = 10, nodePadding = 10 } = options\n\t\tgridRatio = toInteger(gridRatio)\n\t\tnodePadding = toInteger(nodePadding)\n\n\t\t// We use the node's information to generate bounding boxes for them\n\t\t// and the graph\n\t\tconst { graphBox, nodeBoxes } = getBoundingBoxes<NodeDataType>(\n\t\t\tnodes,\n\t\t\tnodePadding,\n\t\t\tgridRatio\n\t\t)\n\n\t\tconst source: PointInfo = {\n\t\t\tx: sourceX,\n\t\t\ty: sourceY,\n\t\t\tposition: sourcePosition\n\t\t}\n\n\t\tconst target: PointInfo = {\n\t\t\tx: targetX,\n\t\t\ty: targetY,\n\t\t\tposition: targetPosition\n\t\t}\n\n\t\t// With this information, we can create a 2D grid representation of\n\t\t// our graph, that tells us where in the graph there is a \"free\" space or not\n\t\tconst { grid, start, end } = createGrid(\n\t\t\tgraphBox,\n\t\t\tnodeBoxes,\n\t\t\tsource,\n\t\t\ttarget,\n\t\t\tgridRatio\n\t\t)\n\n\t\t// We then can use the grid representation to do pathfinding\n\t\tconst generatePathResult = generatePath(grid, start, end)\n\n\t\tif (generatePathResult === null) {\n\t\t\treturn null\n\t\t}\n\n\t\tconst { fullPath, smoothedPath } = generatePathResult\n\n\t\t// Here we convert the grid path to a sequence of graph coordinates.\n\t\tconst graphPath = smoothedPath.map((gridPoint) => {\n\t\t\tconst [x, y] = gridPoint\n\t\t\tconst graphPoint = gridToGraphPoint(\n\t\t\t\t{ x, y },\n\t\t\t\tgraphBox.xMin,\n\t\t\t\tgraphBox.yMin,\n\t\t\t\tgridRatio\n\t\t\t)\n\t\t\treturn [graphPoint.x, graphPoint.y]\n\t\t})\n\n\t\t// Finally, we can use the graph path to draw the edge\n\t\tconst svgPathString = drawEdge(source, target, graphPath)\n\n\t\t// Compute the edge's middle point using the full path, so users can use\n\t\t// it to position their custom labels\n\t\tconst index = Math.floor(fullPath.length / 2)\n\t\tconst middlePoint = fullPath[index]\n\t\tconst [middleX, middleY] = middlePoint\n\t\tconst { x: edgeCenterX, y: edgeCenterY } = gridToGraphPoint(\n\t\t\t{ x: middleX, y: middleY },\n\t\t\tgraphBox.xMin,\n\t\t\tgraphBox.yMin,\n\t\t\tgridRatio\n\t\t)\n\n\t\treturn { svgPathString, edgeCenterX, edgeCenterY }\n\t} catch {\n\t\treturn null\n\t}\n}\n\nexport type GetSmartEdgeFunction = typeof getSmartEdge\n","import { roundUp, roundDown } from './utils'\nimport type { Node, XYPosition } from 'reactflow'\n\nexport type NodeBoundingBox = {\n\tid: string\n\twidth: number\n\theight: number\n\ttopLeft: XYPosition\n\tbottomLeft: XYPosition\n\ttopRight: XYPosition\n\tbottomRight: XYPosition\n}\n\nexport type GraphBoundingBox = {\n\twidth: number\n\theight: number\n\ttopLeft: XYPosition\n\tbottomLeft: XYPosition\n\ttopRight: XYPosition\n\tbottomRight: XYPosition\n\txMax: number\n\tyMax: number\n\txMin: number\n\tyMin: number\n}\n\n/**\n * Get the bounding box of all nodes and the graph itself, as X/Y coordinates\n * of all corner points.\n *\n * @param nodes The node list\n * @param nodePadding Optional padding to add to the node's and graph bounding boxes\n * @param roundTo Everything will be rounded to this nearest integer\n * @returns Graph and nodes bounding boxes.\n */\nexport const getBoundingBoxes = <NodeDataType = unknown>(\n\tnodes: Node<NodeDataType>[],\n\tnodePadding = 2,\n\troundTo = 2\n) => {\n\tlet xMax = Number.MIN_SAFE_INTEGER\n\tlet yMax = Number.MIN_SAFE_INTEGER\n\tlet xMin = Number.MAX_SAFE_INTEGER\n\tlet yMin = Number.MAX_SAFE_INTEGER\n\n\tconst nodeBoxes: NodeBoundingBox[] = nodes.map((node) => {\n\t\tconst width = Math.max(node.width || 0, 1)\n\t\tconst height = Math.max(node.height || 0, 1)\n\n\t\tconst position: XYPosition = {\n\t\t\tx: node.positionAbsolute?.x || 0,\n\t\t\ty: node.positionAbsolute?.y || 0\n\t\t}\n\n\t\tconst topLeft: XYPosition = {\n\t\t\tx: position.x - nodePadding,\n\t\t\ty: position.y - nodePadding\n\t\t}\n\t\tconst bottomLeft: XYPosition = {\n\t\t\tx: position.x - nodePadding,\n\t\t\ty: position.y + height + nodePadding\n\t\t}\n\t\tconst topRight: XYPosition = {\n\t\t\tx: position.x + width + nodePadding,\n\t\t\ty: position.y - nodePadding\n\t\t}\n\t\tconst bottomRight: XYPosition = {\n\t\t\tx: position.x + width + nodePadding,\n\t\t\ty: position.y + height + nodePadding\n\t\t}\n\n\t\tif (roundTo > 0) {\n\t\t\ttopLeft.x = roundDown(topLeft.x, roundTo)\n\t\t\ttopLeft.y = roundDown(topLeft.y, roundTo)\n\t\t\tbottomLeft.x = roundDown(bottomLeft.x, roundTo)\n\t\t\tbottomLeft.y = roundUp(bottomLeft.y, roundTo)\n\t\t\ttopRight.x = roundUp(topRight.x, roundTo)\n\t\t\ttopRight.y = roundDown(topRight.y, roundTo)\n\t\t\tbottomRight.x = roundUp(bottomRight.x, roundTo)\n\t\t\tbottomRight.y = roundUp(bottomRight.y, roundTo)\n\t\t}\n\n\t\tif (topLeft.y < yMin) yMin = topLeft.y\n\t\tif (topLeft.x < xMin) xMin = topLeft.x\n\t\tif (bottomRight.y > yMax) yMax = bottomRight.y\n\t\tif (bottomRight.x > xMax) xMax = bottomRight.x\n\n\t\treturn {\n\t\t\tid: node.id,\n\t\t\twidth,\n\t\t\theight,\n\t\t\ttopLeft,\n\t\t\tbottomLeft,\n\t\t\ttopRight,\n\t\t\tbottomRight\n\t\t}\n\t})\n\n\tconst graphPadding = nodePadding * 2\n\n\txMax = roundUp(xMax + graphPadding, roundTo)\n\tyMax = roundUp(yMax + graphPadding, roundTo)\n\txMin = roundDown(xMin - graphPadding, roundTo)\n\tyMin = roundDown(yMin - graphPadding, roundTo)\n\n\tconst topLeft: XYPosition = {\n\t\tx: xMin,\n\t\ty: yMin\n\t}\n\n\tconst bottomLeft: XYPosition = {\n\t\tx: xMin,\n\t\ty: yMax\n\t}\n\n\tconst topRight: XYPosition = {\n\t\tx: xMax,\n\t\ty: yMin\n\t}\n\n\tconst bottomRight: XYPosition = {\n\t\tx: xMax,\n\t\ty: yMax\n\t}\n\n\tconst width = Math.abs(topLeft.x - topRight.x)\n\tconst height = Math.abs(topLeft.y - bottomLeft.y)\n\n\tconst graphBox: GraphBoundingBox = {\n\t\ttopLeft,\n\t\tbottomLeft,\n\t\ttopRight,\n\t\tbottomRight,\n\t\twidth,\n\t\theight,\n\t\txMax,\n\t\tyMax,\n\t\txMin,\n\t\tyMin\n\t}\n\n\treturn { nodeBoxes, graphBox }\n}\n","import { Grid } from 'pathfinding'\nimport {\n\tguaranteeWalkablePath,\n\tgetNextPointFromPosition\n} from './guaranteeWalkablePath'\nimport { graphToGridPoint } from './pointConversion'\nimport { round, roundUp } from './utils'\nimport type { NodeBoundingBox, GraphBoundingBox } from './getBoundingBoxes'\nimport type { Position } from 'reactflow'\n\nexport type PointInfo = {\n\tx: number\n\ty: number\n\tposition: Position\n}\n\nexport const createGrid = (\n\tgraph: GraphBoundingBox,\n\tnodes: NodeBoundingBox[],\n\tsource: PointInfo,\n\ttarget: PointInfo,\n\tgridRatio = 2\n) => {\n\tconst { xMin, yMin, width, height } = graph\n\n\t// Create a grid representation of the graph box, where each cell is\n\t// equivalent to 10x10 pixels (or the grid ratio) on the graph. We'll use\n\t// this simplified grid to do pathfinding.\n\tconst mapColumns = roundUp(width, gridRatio) / gridRatio + 1\n\tconst mapRows = roundUp(height, gridRatio) / gridRatio + 1\n\tconst grid = new Grid(mapColumns, mapRows)\n\n\t// Update the grid representation with the space the nodes take up\n\tnodes.forEach((node) => {\n\t\tconst nodeStart = graphToGridPoint(node.topLeft, xMin, yMin, gridRatio)\n\t\tconst nodeEnd = graphToGridPoint(node.bottomRight, xMin, yMin, gridRatio)\n\n\t\tfor (let x = nodeStart.x; x < nodeEnd.x; x++) {\n\t\t\tfor (let y = nodeStart.y; y < nodeEnd.y; y++) {\n\t\t\t\tgrid.setWalkableAt(x, y, false)\n\t\t\t}\n\t\t}\n\t})\n\n\t// Convert the starting and ending graph points to grid points\n\tconst startGrid = graphToGridPoint(\n\t\t{\n\t\t\tx: round(source.x, gridRatio),\n\t\t\ty: round(source.y, gridRatio)\n\t\t},\n\t\txMin,\n\t\tyMin,\n\t\tgridRatio\n\t)\n\n\tconst endGrid = graphToGridPoint(\n\t\t{\n\t\t\tx: round(target.x, gridRatio),\n\t\t\ty: round(target.y, gridRatio)\n\t\t},\n\t\txMin,\n\t\tyMin,\n\t\tgridRatio\n\t)\n\n\t// Guarantee a walkable path between the start and end points, even if the\n\t// source or target where covered by another node or by padding\n\tconst startingNode = grid.getNodeAt(startGrid.x, startGrid.y)\n\tguaranteeWalkablePath(grid, startingNode, source.position)\n\tconst endingNode = grid.getNodeAt(endGrid.x, endGrid.y)\n\tguaranteeWalkablePath(grid, endingNode, target.position)\n\n\t// Use the next closest points as the start and end points, so\n\t// pathfinding does not start too close to the nodes\n\tconst start = getNextPointFromPosition(startingNode, source.position)\n\tconst end = getNextPointFromPosition(endingNode, target.position)\n\n\treturn { grid, start, end }\n}\n","import React from 'react'\nimport { BezierEdge, BaseEdge } from 'reactflow'\nimport { getSmartEdge } from '../getSmartEdge'\nimport type { GetSmartEdgeOptions } from '../getSmartEdge'\nimport type { EdgeProps, Node } from 'reactflow'\n\nexport type EdgeElement = typeof BezierEdge\n\nexport type SmartEdgeOptions = GetSmartEdgeOptions & {\n\tfallback?: EdgeElement\n}\n\nexport interface SmartEdgeProps<EdgeDataType = unknown, NodeDataType = unknown>\n\textends EdgeProps<EdgeDataType> {\n\tnodes: Node<NodeDataType>[]\n\toptions: SmartEdgeOptions\n}\n\nexport function SmartEdge<EdgeDataType = unknown, NodeDataType = unknown>({\n\tnodes,\n\toptions,\n\t...edgeProps\n}: SmartEdgeProps<EdgeDataType, NodeDataType>) {\n\tconst {\n\t\tsourceX,\n\t\tsourceY,\n\t\tsourcePosition,\n\t\ttargetX,\n\t\ttargetY,\n\t\ttargetPosition,\n\t\tstyle,\n\t\tlabel,\n\t\tlabelStyle,\n\t\tlabelShowBg,\n\t\tlabelBgStyle,\n\t\tlabelBgPadding,\n\t\tlabelBgBorderRadius,\n\t\tmarkerEnd,\n\t\tmarkerStart,\n\t\tinteractionWidth\n\t} = edgeProps\n\n\tconst smartResponse = getSmartEdge({\n\t\tsourcePosition,\n\t\ttargetPosition,\n\t\tsourceX,\n\t\tsourceY,\n\t\ttargetX,\n\t\ttargetY,\n\t\toptions,\n\t\tnodes\n\t})\n\n\tconst FallbackEdge = options.fallback || BezierEdge\n\n\tif (smartResponse === null) {\n\t\treturn <FallbackEdge {...edgeProps} />\n\t}\n\n\tconst { edgeCenterX, edgeCenterY, svgPathString } = smartResponse\n\n\treturn (\n\t\t<BaseEdge\n\t\t\tpath={svgPathString}\n\t\t\tlabelX={edgeCenterX}\n\t\t\tlabelY={edgeCenterY}\n\t\t\tlabel={label}\n\t\t\tlabelStyle={labelStyle}\n\t\t\tlabelShowBg={labelShowBg}\n\t\t\tlabelBgStyle={labelBgStyle}\n\t\t\tlabelBgPadding={labelBgPadding}\n\t\t\tlabelBgBorderRadius={labelBgBorderRadius}\n\t\t\tstyle={style}\n\t\t\tmarkerStart={markerStart}\n\t\t\tmarkerEnd={markerEnd}\n\t\t\tinteractionWidth={interactionWidth}\n\t\t/>\n\t)\n}\n\nexport type SmartEdgeFunction = typeof SmartEdge\n","import React from 'react'\nimport { useNodes, BezierEdge } from 'reactflow'\nimport { SmartEdge } from '../SmartEdge'\nimport { svgDrawSmoothLinePath, pathfindingAStarDiagonal } from '../functions'\nimport type { SmartEdgeOptions } from '../SmartEdge'\nimport type { EdgeProps } from 'reactflow'\n\nconst BezierConfiguration: SmartEdgeOptions = {\n\tdrawEdge: svgDrawSmoothLinePath,\n\tgeneratePath: pathfindingAStarDiagonal,\n\tfallback: BezierEdge\n}\n\nexport function SmartBezierEdge<EdgeDataType = unknown, NodeDataType = unknown>(\n\tprops: EdgeProps<EdgeDataType>\n) {\n\tconst nodes = useNodes<NodeDataType>()\n\n\treturn (\n\t\t<SmartEdge<EdgeDataType, NodeDataType>\n\t\t\t{...props}\n\t\t\toptions={BezierConfiguration}\n\t\t\tnodes={nodes}\n\t\t/>\n\t)\n}\n","import React from 'react'\nimport { useNodes, StepEdge } from 'reactflow'\nimport { SmartEdge } from '../SmartEdge'\nimport {\n\tsvgDrawStraightLinePath,\n\tpathfindingJumpPointNoDiagonal\n} from '../functions'\nimport type { SmartEdgeOptions } from '../SmartEdge'\nimport type { EdgeProps } from 'reactflow'\n\nconst StepConfiguration: SmartEdgeOptions = {\n\tdrawEdge: svgDrawStraightLinePath,\n\tgeneratePath: pathfindingJumpPointNoDiagonal,\n\tfallback: StepEdge\n}\n\nexport function SmartStepEdge<EdgeDataType = unknown, NodeDataType = unknown>(\n\tprops: EdgeProps<EdgeDataType>\n) {\n\tconst nodes = useNodes<NodeDataType>()\n\n\treturn (\n\t\t<SmartEdge<EdgeDataType, NodeDataType>\n\t\t\t{...props}\n\t\t\toptions={StepConfiguration}\n\t\t\tnodes={nodes}\n\t\t/>\n\t)\n}\n","import React from 'react'\nimport { useNodes, StraightEdge } from 'reactflow'\nimport { SmartEdge } from '../SmartEdge'\nimport {\n\tsvgDrawStraightLinePath,\n\tpathfindingAStarNoDiagonal\n} from '../functions'\nimport type { SmartEdgeOptions } from '../SmartEdge'\nimport type { EdgeProps } from 'reactflow'\n\nconst StraightConfiguration: SmartEdgeOptions = {\n\tdrawEdge: svgDrawStraightLinePath,\n\tgeneratePath: pathfindingAStarNoDiagonal,\n\tfallback: StraightEdge\n}\n\nexport function SmartStraightEdge<\n\tEdgeDataType = unknown,\n\tNodeDataType = unknown\n>(props: EdgeProps<EdgeDataType>) {\n\tconst nodes = useNodes<NodeDataType>()\n\n\treturn (\n\t\t<SmartEdge<EdgeDataType, NodeDataType>\n\t\t\t{...props}\n\t\t\toptions={StraightConfiguration}\n\t\t\tnodes={nodes}\n\t\t/>\n\t)\n}\n"],"names":["getNextPointFromPosition","point","position","x","y","guaranteeWalkablePath","grid","node","getNodeAt","walkable","setWalkableAt","next","graphToGridPoint","graphPoint","smallestX","smallestY","gridRatio","referenceX","referenceY","gridToGraphPoint","gridPoint","round","multiple","Math","roundDown","floor","roundUp","ceil","toInteger","value","min","result","max","Number","isInteger","svgDrawStraightLinePath","source","target","path","svgPathString","forEach","svgDrawSmoothLinePath","points","quadraticBezierCurve","first","svgPath","i","length","midPoint","getMidPoint","last","Ax","Ay","Bx","By","pathfindingAStarDiagonal","start","end","fullPath","AStarFinder","diagonalMovement","DiagonalMovement","Always","findPath","smoothedPath","Util","smoothenPath","_unused","pathfindingAStarNoDiagonal","Never","_unused2","pathfindingJumpPointNoDiagonal","JumpPointFinder","_unused3","getSmartEdge","_ref","_ref$options","options","_ref$nodes","nodes","sourceX","sourceY","targetX","targetY","sourcePosition","targetPosition","drawEdge","_options$drawEdge","_options$generatePath","generatePath","_options$gridRatio","_options$nodePadding","nodePadding","_getBoundingBoxes","roundTo","xMax","MIN_SAFE_INTEGER","yMax","xMin","MAX_SAFE_INTEGER","yMin","nodeBoxes","map","_node$positionAbsolut","_node$positionAbsolut2","width","height","positionAbsolute","topLeft","bottomLeft","topRight","bottomRight","id","graphPadding","graphBox","abs","getBoundingBoxes","createGrid","graph","mapColumns","mapRows","Grid","nodeStart","nodeEnd","startGrid","endGrid","startingNode","endingNode","generatePathResult","middlePoint","_gridToGraphPoint","edgeCenterX","edgeCenterY","SmartEdge","edgeProps","_objectWithoutPropertiesLoose","_excluded","style","label","labelStyle","labelShowBg","labelBgStyle","labelBgPadding","labelBgBorderRadius","markerEnd","markerStart","interactionWidth","smartResponse","React","createElement","fallback","BezierEdge","_extends","BaseEdge","labelX","labelY","BezierConfiguration","SmartBezierEdge","props","useNodes","StepConfiguration","StepEdge","StraightConfiguration","StraightEdge"],"mappings":"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"}